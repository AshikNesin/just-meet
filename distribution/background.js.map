{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/webext-detect-page/index.js","webpack:///./node_modules/webext-options-sync/index.js","webpack:///./source/background.js","webpack:///./source/options-storage.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC3Ba;AACb,6BAA6B,mBAAO,CAAC,sEAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,wCAAwC;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wDAAwD,iBAAiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+BAA+B;AACjF;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,OAAO;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACnNA;AAAA;AAAA;AAC2B;;;;;;;;;;;;;ACD3B;AAAA;AAAA;AAA8C;;AAE/B,mEAAI,0DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE,0DAAW;AACb;AACA;AACA,CAAC,CAAC,EAAC","file":"background.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./source/background.js\");\n","\"use strict\";\n// https://github.com/bfred-it/webext-detect-page\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isBackgroundPage() {\n    return location.pathname === '/_generated_background_page.html' &&\n        !location.protocol.startsWith('http') &&\n        Boolean(typeof chrome === 'object' && chrome.runtime);\n}\nexports.isBackgroundPage = isBackgroundPage;\nfunction isContentScript() {\n    return location.protocol.startsWith('http') &&\n        Boolean(typeof chrome === 'object' && chrome.runtime);\n}\nexports.isContentScript = isContentScript;\nfunction isOptionsPage() {\n    if (typeof chrome !== 'object' || !chrome.runtime) {\n        return false;\n    }\n    const { options_ui } = chrome.runtime.getManifest();\n    if (typeof options_ui !== 'object' || typeof options_ui.page !== 'string') {\n        return false;\n    }\n    const url = new URL(options_ui.page, location.origin);\n    return url.pathname === location.pathname &&\n        url.origin === location.origin;\n}\nexports.isOptionsPage = isOptionsPage;\n//# sourceMappingURL=index.js.map","\"use strict\";\nconst webext_detect_page_1 = require(\"webext-detect-page\");\nclass OptionsSync {\n    /**\n    @constructor Returns an instance linked to the chosen storage.\n    @param options - Configuration to determine where options are stored.\n    */\n    constructor(options) {\n        const fullOptions = {\n            // https://github.com/bfred-it/webext-options-sync/pull/21#issuecomment-500314074\n            // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n            defaults: {},\n            storageName: 'options',\n            migrations: [],\n            logging: true,\n            ...options\n        };\n        this.storageName = fullOptions.storageName;\n        this.defaults = fullOptions.defaults;\n        if (fullOptions.logging === false) {\n            this._log = () => { };\n        }\n        if (webext_detect_page_1.isBackgroundPage()) {\n            chrome.management.getSelf(({ installType }) => {\n                // Chrome doesn't run `onInstalled` when launching the browser with a pre-loaded development extension #25\n                if (installType === 'development') {\n                    this._applyDefinition(fullOptions);\n                }\n                else {\n                    chrome.runtime.onInstalled.addListener(() => this._applyDefinition(fullOptions));\n                }\n            });\n        }\n        this._handleFormUpdatesDebounced = this._handleFormUpdatesDebounced.bind(this);\n    }\n    _log(method, ...args) {\n        console[method](...args);\n    }\n    async _applyDefinition(defs) {\n        const options = { ...defs.defaults, ...await this.getAll() };\n        this._log('group', 'Appling definitions');\n        this._log('info', 'Current options:', options);\n        if (defs.migrations && defs.migrations.length > 0) {\n            this._log('info', 'Running', defs.migrations.length, 'migrations');\n            defs.migrations.forEach(migrate => migrate(options, defs.defaults));\n        }\n        this._log('info', 'Migrated options:', options);\n        this._log('groupEnd');\n        this.setAll(options);\n    }\n    _parseNumbers(options) {\n        for (const name of Object.keys(options)) {\n            if (options[name] === String(Number(options[name]))) {\n                // @ts-ignore it will be dropped in #13\n                options[name] = Number(options[name]);\n            }\n        }\n        return options;\n    }\n    /**\n    Retrieves all the options stored.\n\n    @returns Promise that will resolve with **all** the options stored, as an object.\n\n    @example\n\n    new OptionsSync().getAll().then(options => {\n        console.log('The userâ€™s options are', options);\n        if (options.color) {\n            document.body.style.color = color;\n        }\n    });\n    */\n    async getAll() {\n        const keys = await new Promise((resolve, reject) => {\n            chrome.storage.sync.get({\n                [this.storageName]: this.defaults\n            }, result => {\n                if (chrome.runtime.lastError) {\n                    reject(chrome.runtime.lastError);\n                }\n                else {\n                    resolve(result);\n                }\n            });\n        });\n        return this._parseNumbers(keys[this.storageName]);\n    }\n    /**\n    Overrides **all** the options stored with your `options`.\n\n    @param newOptions - A map of default options as strings or booleans. The keys will have to match the form fields' `name` attributes.\n    */\n    async setAll(newOptions) {\n        return new Promise((resolve, reject) => {\n            chrome.storage.sync.set({\n                [this.storageName]: newOptions\n            }, () => {\n                if (chrome.runtime.lastError) {\n                    reject(chrome.runtime.lastError);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n    }\n    /**\n    Merges new options with the existing stored options.\n\n    @param newOptions - A map of default options as strings or booleans. The keys will have to match the form fields' `name` attributes.\n    */\n    async set(newOptions) {\n        return this.setAll({ ...await this.getAll(), ...newOptions });\n    }\n    /**\n    Any defaults or saved options will be loaded into the `<form>` and any change will automatically be saved via `chrome.storage.sync`.\n\n    @param selector - The `<form>` that needs to be synchronized or a CSS selector (one element).\n    The form fields' `name` attributes will have to match the option names.\n    */\n    async syncForm(form) {\n        const element = form instanceof HTMLFormElement ?\n            form :\n            document.querySelector(form);\n        element.addEventListener('input', this._handleFormUpdatesDebounced);\n        element.addEventListener('change', this._handleFormUpdatesDebounced);\n        chrome.storage.onChanged.addListener((changes, namespace) => {\n            if (namespace === 'sync' &&\n                changes[this.storageName] &&\n                !element.contains(document.activeElement) // Avoid applying changes while the user is editing a field\n            ) {\n                this._applyToForm(changes[this.storageName].newValue, element);\n            }\n        });\n        this._applyToForm(await this.getAll(), element);\n    }\n    _applyToForm(options, form) {\n        this._log('group', 'Updating form');\n        for (const name of Object.keys(options)) {\n            const els = form.querySelectorAll(`[name=\"${CSS.escape(name)}\"]`);\n            const [field] = els;\n            if (field) {\n                this._log('info', name, ':', options[name]);\n                switch (field.type) {\n                    case 'checkbox':\n                        field.checked = options[name];\n                        break;\n                    case 'radio': {\n                        const [selected] = [...els].filter(el => el.value === options[name]);\n                        if (selected) {\n                            selected.checked = true;\n                        }\n                        break;\n                    }\n                    default:\n                        field.value = options[name];\n                        break;\n                }\n                field.dispatchEvent(new InputEvent('input'));\n            }\n            else {\n                this._log('warn', 'Stored option {', name, ':', options[name], '} was not found on the page');\n            }\n        }\n        this._log('groupEnd');\n    }\n    _handleFormUpdatesDebounced({ target }) {\n        if (this._timer) {\n            clearTimeout(this._timer);\n        }\n        this._timer = setTimeout(() => {\n            this._handleFormUpdates(target);\n            this._timer = undefined;\n        }, 600);\n    }\n    _handleFormUpdates(el) {\n        const { name } = el;\n        let { value } = el;\n        if (!name || !el.validity.valid) {\n            return;\n        }\n        switch (el.type) {\n            case 'select-one':\n                value = el.options[el.selectedIndex].value;\n                break;\n            case 'checkbox':\n                value = el.checked;\n                break;\n            default: break;\n        }\n        this._log('info', 'Saving option', el.name, 'to', value);\n        // @ts-ignore `name` should be a keyof TOptions but it's a plain string, so it fails\n        this.set({\n            [name]: value\n        });\n    }\n}\nOptionsSync.migrations = {\n    /**\n    Helper method that removes any option that isn't defined in the defaults. It's useful to avoid leaving old options taking up space.\n    */\n    removeUnused(options, defaults) {\n        for (const key of Object.keys(options)) {\n            if (!(key in defaults)) {\n                delete options[key];\n            }\n        }\n    }\n};\nmodule.exports = OptionsSync;\n//# sourceMappingURL=index.js.map","// eslint-disable-next-line import/no-unassigned-import\nimport './options-storage';\n","import OptionsSync from 'webext-options-sync';\n\nexport default new OptionsSync({\n\tdefaults: {\n\t\tautoMuteOnJoin: true,\n\t\tautoJoinCall:true,\n\t\tautoTurnOffCamOnJoin: true,\n\t\tdebugMode:false\n\t},\n\tmigrations: [\n\t\tOptionsSync.migrations.removeUnused\n\t],\n\tlogging: true\n});\n"],"sourceRoot":""}